# PGAdapter and Django

PGAdapter can be used in combination with Django, but with a number of limitations. This sample
shows the command line arguments and configuration that is needed in order to use Django with
PGAdapter.

## Start PGAdapter
You must start PGAdapter before you can run the sample. The following command shows how to start PGAdapter using the
pre-built Docker image. See [Running PGAdapter](../../../README.md#usage) for more information on other options for how
to run PGAdapter.

```shell
export GOOGLE_APPLICATION_CREDENTIALS=/path/to/credentials.json
docker pull gcr.io/cloud-spanner-pg-adapter/pgadapter
docker run \
  -d -p 5432:5432 \
  -v ${GOOGLE_APPLICATION_CREDENTIALS}:${GOOGLE_APPLICATION_CREDENTIALS}:ro \
  -e GOOGLE_APPLICATION_CREDENTIALS \
  -v /tmp:/tmp \
  gcr.io/cloud-spanner-pg-adapter/pgadapter \
  -p my-project -i my-instance \
  -x
```

## Creating the Sample Data Model
Run the following command in this directory. Replace the host, port and database name with the actual host, port and
database name for your PGAdapter and database setup.

```shell
psql -h localhost -p 5432 -d my-database -f sample-schema.sql
```

You can also drop an existing data model using the `drop_data_model.sql` script:

```shell
psql -h localhost -p 5432 -d my-database -f drop-data-model.sql
```

## Data Types
Cloud Spanner supports the following data types in combination with `Django`.

| PostgreSQL Type                        | Django Model Field |
|----------------------------------------|--------------------|
| boolean                                | BoolField          |
| bigint / int8                          | BigIntegerField    |
| varchar                                | CharField          |
| text                                   | CharField          |
| float8 / double precision              | FloatField         |
| numeric                                | DecimalField       |
| timestamptz / timestamp with time zone | DateTimeField      |
| bytea                                  | BinaryField        |
| date                                   | DateField          |

## Limitations
The following limitations are currently known:

| Limitation             | Workaround                                                                                                                                                                                                                                                                                          |
|------------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| Annotate               | Cloud Spanner does not support selecting columns in an aggregation query that are not involved in the aggregation functions or `GROUP BY` clause. Due to this, many times performing `annotate` function over a querySet might fail.                                                                |
| Generated primary keys | Cloud Spanner does not support `sequences`. Auto-increment primary key is not supported. Avoid using fields like `AutoField`, `BigAutoField`, etc. . The recommended type of primary key is a client side generated `UUID` stored as a string.                                                      |
| Savepoint              | Cloud Spanner does not support `savepoints` and hence, functions related to `savepoints` in django are not supported in the PGAdapter.                                                                                                                                                              |
| Nested Atomic Blocks   | Nested atomic blocks make use of `savepoints`, which is currently not supported by Cloud Spanner. Hence, while using nested atomic blocks make sure to set `savepoint=False`, in the argument.                                                                                                      |
| Interleaved Table      | Django doesn't support composite primary keys and interleaved table in cloud spanner requires a composite primary key and on the top of that, it is also not possible to create a django model without a primary key. A possible workaround around for using interleaved table is documented below. |


### Annotate
`annotate` is not fully supported in the PGAdapter.


### Generated Primary Keys
`Sequences` are not supported. Hence, auto increment primary key is not supported and should be replaced with primary key definitions that
are manually assigned. See https://cloud.google.com/spanner/docs/schema-design#primary-key-prevent-hotspots
for more information on choosing a good primary key. This sample uses UUIDs that are generated by the client for primary
keys.

### Savepoint
`savepoints` are supported in the Cloud Spanner. Hence, following functions from the `django.db.transaction` are not supported

```python
from django.db import  transaction
transaction.savepoint()
transaction.savepoint_rollback()
transaction.savepoint_commit()
transaction.clean_savepoints()
```

### Nested Atomic Blocks
As mentioned earlier also, `savepoints` are not supported and hence, a code like follows might not work with PGAdapter
because it will make use of savepoint to make sure the inner nested block is rolled back properly 
if some error occurs over there.
```python
from django.db import transaction

@transaction.atomic
def func():
  do_stuff
  with transaction.atomic():
    do_some_more_stuff
```

Instead of above, always set `savepoint=False` while using nested atomic blocks
```python
from django.db import transaction

@transaction.atomic(savepoint=False)
def func():
  do_stuff
  with transaction.atomic(savepoint=False):
    do_some_more_stuff
```

### Interleaved Tables
A possible workaround for Django's inability to use interleaved table with Django and PGAdapter includes 
having a column which has unique index in the actual table while pretending to Django like it's a primary key. 

One important thing to note here is that we can't use usual `save` function for creating new records for such a model 
because that might generate an `UPDATE` statement which will try to update the unique index. 
So, we will have to use `force_insert = True`, while creating new records. For more details, see the sample application.