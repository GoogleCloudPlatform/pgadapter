# PGAdapter and Django

PGAdapter can be used in combination with Django, but with a number of limitations. This sample
shows the command line arguments and configuration that is needed in order to use Django with
PGAdapter.

## Start PGAdapter
You must start PGAdapter before you can run the sample. The following command shows how to start PGAdapter using the
pre-built Docker image. See [Running PGAdapter](../../../README.md#usage) for more information on other options for how
to run PGAdapter.

```shell
export GOOGLE_APPLICATION_CREDENTIALS=/path/to/credentials.json
docker pull gcr.io/cloud-spanner-pg-adapter/pgadapter
docker run \
  -d -p 5432:5432 \
  -v ${GOOGLE_APPLICATION_CREDENTIALS}:${GOOGLE_APPLICATION_CREDENTIALS}:ro \
  -e GOOGLE_APPLICATION_CREDENTIALS \
  -v /tmp:/tmp \
  gcr.io/cloud-spanner-pg-adapter/pgadapter \
  -p my-project -i my-instance \
  -x
```

## Creating the Sample Data Model
Run the following command in this directory. Replace the host, port and database name with the actual host, port and
database name for your PGAdapter and database setup.

```shell
psql -h localhost -p 5432 -d my-database -f sample-schema.sql
```

You can also drop an existing data model using the `drop_data_model.sql` script:

```shell
psql -h localhost -p 5432 -d my-database -f drop-data-model.sql
```

## Data Types
Cloud Spanner supports the following data types in combination with `Django`.

| PostgreSQL Type                        | Django Model Field |
|----------------------------------------|--------------------|
| boolean                                | BoolField          |
| bigint / int8                          | BigIntegerField    |
| varchar                                | CharField          |
| text                                   | CharField          |
| float8 / double precision              | FloatField         |
| numeric                                | DecimalField       |
| timestamptz / timestamp with time zone | DateTimeField      |
| bytea                                  | BinaryField        |
| date                                   | DateField          |

## Limitations
The following limitations are currently known:

| Limitation             | Workaround                                                                                                                                                                                                                                                             |
|------------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| Annotate               | Cloud Spanner does not support selecting columns in an aggregation query that are not included in the aggregation functions or `GROUP BY` clause. Adding an aggregation on a query using `annotate` will therefore often generate an unsupported query.                |
| Generated primary keys | Cloud Spanner does not support `sequences`. Auto-increment primary key is not supported. Avoid using fields like `AutoField`, `BigAutoField`, etc. . The recommended type of primary key is a client side generated `UUID` stored as a string.                         |
| Savepoint              | Cloud Spanner does not support `savepoints`. Creating or rolling back to a `Savepoint` in django is not supported in PGAdapter.                                                                                                                                        |
| Nested Atomic Blocks   | Nested atomic blocks use `savepoints`, which is currently not supported by Cloud Spanner. Ensure to set `savepoint=False` when using nested atomic blocks.                                                                                                             |
| Interleaved Table      | Django does not support composite primary keys. Interleaved tables in Cloud Spanner require composite primary keys. A possible workaround for using interleaved tables is documented below.                                                                            |


### Annotate
`annotate` is not fully supported in the PGAdapter.


### Generated Primary Keys
`Sequences` are not supported. Hence, auto increment primary key is not supported and should be replaced with primary key definitions that
are manually assigned. See https://cloud.google.com/spanner/docs/schema-design#primary-key-prevent-hotspots
for more information on choosing a good primary key. This sample uses UUIDs that are generated by the client for primary
keys.

### Savepoint
`savepoints` are not supported in Cloud Spanner. The following functions in Django are therefore also not supported:

```python
from django.db import  transaction
transaction.savepoint()
transaction.savepoint_rollback()
transaction.savepoint_commit()
transaction.clean_savepoints()
```

### Nested Atomic Blocks
`Savepoints` are not supported in Cloud Spanner. Nested atomic blocks in `django` will by default create a
`Savepoint` when an inner block is entered. You can suppress this behavior by adding `savepoint=False` to
the `@transaction.atomic` annotation.
```python
from django.db import transaction

@transaction.atomic
def func():
  do_stuff
  with transaction.atomic():
    do_some_more_stuff
```

Instead of above, always set `savepoint=False` while using nested atomic blocks
```python
from django.db import transaction

@transaction.atomic(savepoint=False)
def func():
  do_stuff
  with transaction.atomic(savepoint=False):
    do_some_more_stuff
```

### Interleaved Tables
A possible workaround for Django's inability to use interleaved table with Django and PGAdapter includes 
having a column which has unique index in the actual table while pretending to Django like it's a primary key. 

One important thing to note here is that we can't use usual `save` function for creating new records for such a model 
because that might generate an `UPDATE` statement which will try to update the unique index. 
So, we will have to use `force_insert = True`, while creating new records. For more details, see the sample application.