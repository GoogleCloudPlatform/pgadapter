// Copyright 2022 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package main

import (
	"database/sql"
	"fmt"
	"github.com/google/uuid"
	"github.com/shopspring/decimal"
	"gorm.io/datatypes"
	"gorm.io/gorm/clause"
	"math/rand"
	"time"

	"gorm.io/driver/postgres"
	"gorm.io/gorm"
)

// BaseModel is embedded in all other models to add common database fields.
type BaseModel struct {
	// ID is the primary key of each model. The ID is generated client side as a UUID.
	ID string
	// CreatedAt and UpdatedAt are managed automatically by gorm.
	CreatedAt time.Time
	UpdatedAt time.Time
}

type Singer struct {
	BaseModel
	FirstName sql.NullString
	LastName  string
	// FullName is generated by the database. The '->' marks this a read-only field. Preferably this field should also
	// include a `default:(-)` annotation, as that would make gorm read the value back using a RETURNING clause. That is
	// however currently not supported.
	FullName string `gorm:"->;type:GENERATED ALWAYS AS (coalesce(concat(first_name,' '::varchar,last_name))) STORED;"`
	Active   bool
	Albums   []Album
}

type Album struct {
	BaseModel
	Title           string
	MarketingBudget decimal.NullDecimal
	ReleaseDate     datatypes.Date
	CoverPicture    []byte
	SingerId        string
	Singer          Singer
	Tracks          []Track `gorm:"foreignKey:ID"`
}

// Track is interleaved in Album. The ID column is both the first part of the primary key of Track, and a
// reference to the Album that owns the Track.
type Track struct {
	BaseModel
	TrackNumber int64 `gorm:"primaryKey;autoIncrement:false"`
	Title       string
	SampleRate  float64
	Album       Album `gorm:"foreignKey:ID"`
}

type Venue struct {
	BaseModel
	Name        string
	Description string
}

type Concert struct {
	BaseModel
	Name      string
	Venue     Venue
	VenueId   string
	Singer    Singer
	SingerId  string
	StartTime time.Time
	EndTime   time.Time
}

var rnd = rand.New(rand.NewSource(time.Now().UnixNano()))

func main() {
	db, err := gorm.Open(postgres.Open("host=/tmp port=5433 database=gorm-sample"), &gorm.Config{})
	if err != nil {
		fmt.Printf("Failed to open gorm connection: %v\n", err)
		return
	}
	conn, err := db.DB()
	if err != nil {
		fmt.Printf("Failed to open database connection: %v\n", err)
		return
	}
	defer conn.Close()

	db.Exec("DELETE FROM concerts")
	db.Exec("DELETE FROM venues")
	db.Exec("DELETE FROM albums")
	db.Exec("DELETE FROM singers")

	for i := 0; i < randInt(5, 10); i++ {
		singerId, err := CreateSinger(db, randFirstName(), randLastName())
		if err != nil {
			fmt.Printf("Failed to create singer: %v\n", err)
			return
		}
		for j := 0; j < randInt(2, 12); j++ {
			_, err = CreateAlbumWithRandomTracks(db, singerId, randAlbumTitle(), randInt(1, 22))
			if err != nil {
				fmt.Printf("Failed to create album: %v\n", err)
				return
			}
		}
	}

	var singers []*Singer
	if err := db.Model(&Singer{}).Preload(clause.Associations).Find(&singers).Error; err != nil {
		fmt.Printf("Failed to load all singers: %v\n", err)
		return
	}
	for _, singer := range singers {
		fmt.Printf("Singer: {%v %v}\n", singer.ID, singer.FullName)
		fmt.Printf("Albums:\n")
		for _, album := range singer.Albums {
			fmt.Printf("\tAlbum: {%v %v}\n", album.ID, album.Title)
			fmt.Printf("\tTracks:\n")
			db.Model(&album).Preload(clause.Associations).Find(&album)
			for _, track := range album.Tracks {
				fmt.Printf("\t\tTrack: {%v %v}\n", track.TrackNumber, track.Title)
			}
		}
	}

	fmt.Printf("Finished running sample\n")
}

func CreateSinger(db *gorm.DB, firstName, lastName string) (string, error) {
	singer := Singer{
		BaseModel: BaseModel{ID: uuid.NewString()},
		FirstName: sql.NullString{String: firstName, Valid: true},
		LastName:  lastName,
	}
	res := db.Create(&singer)
	return singer.ID, res.Error
}

func CreateAlbumWithRandomTracks(db *gorm.DB, singerId, albumTitle string, numTracks int) (string, error) {
	albumId := uuid.NewString()
	// We cannot include the Tracks that we want to create in the definition here, as gorm would then try to
	// use an UPSERT to save-or-update the album that we are creating. Instead, we need to create the album first,
	// and then create the tracks.
	res := db.Create(&Album{
		BaseModel:       BaseModel{ID: albumId},
		Title:           albumTitle,
		MarketingBudget: decimal.NullDecimal{Decimal: decimal.NewFromFloat(randFloat64(0, 10000000))},
		SingerId:        singerId,
	})
	if res.Error != nil {
		return albumId, res.Error
	}
	tracks := make([]*Track, numTracks)
	for n := 0; n < numTracks; n++ {
		tracks[n] = &Track{BaseModel: BaseModel{ID: albumId}, TrackNumber: int64(n + 1), Title: randTrackTitle()}
	}
	res = db.CreateInBatches(tracks, 8)
	return albumId, res.Error
}

func randFloat64(min, max float64) float64 {
	return min + rnd.Float64()*(max-min)
}

func randInt(min, max int) int {
	return min + rnd.Int()%max
}

func randFirstName() string {
	return firstNames[randInt(0, len(firstNames))]
}

func randLastName() string {
	return lastNames[randInt(0, len(lastNames))]
}

func randAlbumTitle() string {
	return adjectives[randInt(0, len(adjectives))] + " " + nouns[randInt(0, len(nouns))]
}

func randTrackTitle() string {
	return adverbs[randInt(0, len(adverbs))] + " " + verbs[randInt(0, len(verbs))]
}

var firstNames = []string{
	"Saffron", "Eleanor", "Ann", "Salma", "Kiera", "Mariam", "Georgie", "Eden", "Carmen", "Darcie",
	"Antony", "Benjamin", "Donald", "Keaton", "Jared", "Simon", "Tanya", "Julian", "Eugene", "Laurence"}
var lastNames = []string{
	"Terry", "Ford", "Mills", "Connolly", "Newton", "Rodgers", "Austin", "Floyd", "Doherty", "Nguyen",
	"Chavez", "Crossley", "Silva", "George", "Baldwin", "Burns", "Russell", "Ramirez", "Hunter", "Fuller",
}
var adjectives = []string{
	"ultra",
	"happy",
	"emotional",
	"filthy",
	"charming",
	"alleged",
	"talented",
	"exotic",
	"lamentable",
	"lewd",
	"old-fashioned",
	"savory",
	"delicate",
	"willing",
	"habitual",
	"upset",
	"gainful",
	"nonchalant",
	"kind",
	"unruly",
}
var nouns = []string{
	"improvement",
	"control",
	"tennis",
	"gene",
	"department",
	"person",
	"awareness",
	"health",
	"development",
	"platform",
	"garbage",
	"suggestion",
	"agreement",
	"knowledge",
	"introduction",
	"recommendation",
	"driver",
	"elevator",
	"industry",
	"extent",
}
var verbs = []string{
	"instruct",
	"rescue",
	"disappear",
	"import",
	"inhibit",
	"accommodate",
	"dress",
	"describe",
	"mind",
	"strip",
	"crawl",
	"lower",
	"influence",
	"alter",
	"prove",
	"race",
	"label",
	"exhaust",
	"reach",
	"remove",
}
var adverbs = []string{
	"cautiously",
	"offensively",
	"immediately",
	"soon",
	"judgementally",
	"actually",
	"honestly",
	"slightly",
	"limply",
	"rigidly",
	"fast",
	"normally",
	"unnecessarily",
	"wildly",
	"unimpressively",
	"helplessly",
	"rightfully",
	"kiddingly",
	"early",
	"queasily",
}

func parseTimestamp(ts string) time.Time {
	t, _ := time.Parse(time.RFC3339Nano, ts)
	return t.UTC()
}
