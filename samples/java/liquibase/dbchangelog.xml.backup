<?xml version="1.0" encoding="UTF-8"?>
<databaseChangeLog
  xmlns="http://www.liquibase.org/xml/ns/dbchangelog"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xmlns:ext="http://www.liquibase.org/xml/ns/dbchangelog-ext"
  xmlns:pro="http://www.liquibase.org/xml/ns/pro"
  xsi:schemaLocation="http://www.liquibase.org/xml/ns/dbchangelog
		http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-latest.xsd
		http://www.liquibase.org/xml/ns/dbchangelog-ext http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-ext.xsd
		http://www.liquibase.org/xml/ns/pro http://www.liquibase.org/xml/ns/pro/liquibase-pro-latest.xsd">

  <!--
    Each change set is applied in a separate transaction. Cloud Spanner however does not support
    DDL transactions, only DDL batches. A DDL batch is not guaranteed to be atomic. If a statement
    in a DDL batch fails, the preceding statements in the batch might have been applied to the
    database.

    Applying multiple DDL statements in a single batch is a lot more efficient than executing each
    statement separately. It is therefore recommended creating one large change set with multiple
    DDL statements instead of multiple small change sets with separate DDL statements whenever
    possible.
   -->
  <changeSet  id="1 - create singers and albums"  author="loite">
    <createTable  tableName="singers">
      <column  name="singer_id"  type="varchar(36)">
        <!-- Setting the primary key name to 'pk_<table_name>' is required! -->
        <constraints
          primaryKey="true"
          primaryKeyName="pk_singers"
          nullable="false"/>
      </column>
      <column  name="first_name"  type="varchar(200)" />
      <column  name="last_name"  type="varchar(200)">
        <constraints nullable="false" />
      </column>
      <column
          name="full_name"
          type="varchar(400)"
          generationType="ALWAYS"
          defaultValueComputed="GENERATED ALWAYS AS (coalesce(first_name || ' ', '') || last_name) STORED">
        <constraints nullable="true" />
      </column>
      <column name="active" type="boolean" defaultValueBoolean="true"/>
    </createTable>
    <createTable  tableName="albums">
      <column  name="album_id"  type="varchar(36)">
        <!-- Setting the primary key name to 'pk_<table_name>' is required! -->
        <constraints
          primaryKey="true"
          primaryKeyName="pk_albums"
          nullable="false"/>
      </column>
      <column  name="title"  type="varchar(200)">
        <constraints nullable="false" />
      </column>
      <column name="singer_id" type="varchar(36)">
        <constraints
          nullable="false"
          foreignKeyName="fk_albums_singers"
          references="singers (singer_id)" />
      </column>
    </createTable>
  </changeSet>

  <!--
    Create a table that is interleaved in a parent table.
    The 'INTERLEAVE IN PARENT' keyword is a Spanner-specific extension to the PostgreSQL DDL dialect.
    We therefore need to modify the SQL manually.
   -->
  <changeSet id="2 - create tracks"  author="loite">
    <createTable  tableName="tracks">
      <!-- Cloud Spanner does not allow adding a primary key after the table has been created, so
       you must add the primary key definition to all columns when creating the table. -->
      <column  name="album_id"  type="varchar(36)">
        <constraints
          primaryKey="true"
          primaryKeyName="pk_tracks"
          nullable="false"/>
      </column>
      <column  name="track_number"  type="bigint">
        <constraints
          primaryKey="true"
          primaryKeyName="pk_tracks"
          nullable="false"/>
      </column>
      <column  name="title"  type="varchar(200)">
        <constraints nullable="false" />
      </column>
    </createTable>
    <!-- Append custom sql to the previous CREATE TABLE statement to interleave it in albums. -->
    <modifySql dbms="postgresql">
      <append value=" interleave in parent albums on delete cascade"/>
    </modifySql>
  </changeSet>

  <!--
    Load data changes can safely be split into multiple change sets. Each change set will use its
    own read/write transaction and is guaranteed to be atomic.
   -->
  <changeSet id="3 - load singers" author="loite">
    <loadData
      encoding="UTF-8"
      file="data/singers.csv"
      quotchar='"'
      relativeToChangelogFile="true"
      separator=";"
      tableName="singers"
      usePreparedStatements="true">
      <column
        name="singer_id"
        type="string"/>
      <column
        name="first_name"
        type="string"/>
      <column
        name="last_name"
        type="string"/>
      <column
        name="active"
        type="boolean"/>
    </loadData>
  </changeSet>
  <changeSet id="4 - load albums" author="loite">
    <loadData
      encoding="UTF-8"
      file="data/albums.csv"
      quotchar='"'
      relativeToChangelogFile="true"
      separator=";"
      tableName="albums"
      usePreparedStatements="true">
      <column
        name="album_id"
        type="string"/>
      <column
        name="singer_id"
        type="string"/>
      <column
        name="title"
        type="string"/>
    </loadData>
  </changeSet>
  <changeSet id="5 - load tracks" author="loite">
    <loadData
      encoding="UTF-8"
      file="data/tracks.csv"
      quotchar='"'
      relativeToChangelogFile="true"
      separator=";"
      tableName="tracks"
      usePreparedStatements="true">
      <column
        name="album_id"
        type="string"/>
      <column
        name="track_number"
        type="numeric"/> <!-- Note: The type here is the internal Liquibase type, not the PG / Spanner NUMERIC data type. -->
      <column
        name="title"
        type="string"/>
    </loadData>
  </changeSet>

  <!-- Add a non-null column to an existing table. -->
  <changeSet id="6 - add duration column to tracks" author="loite">
    <addColumn tableName="tracks">
      <!--
        Add a non-null column. Note that we are using 'defaultValue' instead of 'defaultValueNumeric here.
        The reason for that is that 'defaultValueNumeric' would be automatically converted to '0', but we
        want '0.0' to be conserved, as only that is a valid NUMERIC default value literal.
      -->
      <column name="duration" type="numeric" defaultValue="0.0">
        <constraints nullable="false" />
      </column>
    </addColumn>
  </changeSet>

  <!-- Create a table that contains a column with each supported data type. -->
  <changeSet id="7 - add table with all types" author="loite">
    <createTable tableName="all_types">
      <column name="col_bigint" type="bigint">
        <!-- NOTE: Setting the primary key name to 'pk_<table_name>' is REQUIRED -->
        <constraints nullable="false" primaryKey="true" primaryKeyName="pk_all_types" />
      </column>
      <column name="col_bool" type="boolean"/>
      <column name="col_bytea" type="bytea"/>
      <column name="col_float8" type="float8"/>
      <column name="col_int" type="int"/> <!-- Note that this will automatically be converted to bigint. -->
      <column name="col_numeric" type="numeric"/>
      <column name="col_timestamptz" type="timestamptz"/>
      <column name="col_date" type="date"/>
      <column name="col_varchar" type="varchar(100)"/>
      <column name="col_text" type="text"/>
    </createTable>
  </changeSet>
  <changeSet id="8 - load data for all data types" author="loite">
    <loadData
      encoding="UTF-8"
      file="data/all_types.csv"
      quotchar='"'
      relativeToChangelogFile="true"
      separator=";"
      tableName="all_types"
      usePreparedStatements="true">
      <column
        name="col_bigint"
        type="numeric"/> <!-- Note: The type here is the internal Liquibase type, not the PG / Spanner NUMERIC data type. -->
      <column
        name="col_bool"
        type="boolean"/>
      <column
        name="col_bytea"
        type="other"/> <!-- We cannot use 'blob', as that is not supported by Cloud Spanner. -->
      <column
        name="col_float8"
        type="numeric"/>
      <column
        name="col_int"
        type="numeric"/>
      <column
        name="col_numeric"
        type="numeric"/>
      <column
        name="col_timestamptz"
        type="other"/> <!-- Use 'other' to ensure that the backend will infer the type of this value. -->
      <column
        name="col_date"
        type="date"/>
      <column
        name="col_varchar"
        type="string"/>
      <column
        name="col_text"
        type="string"/>
    </loadData>
  </changeSet>
</databaseChangeLog>
